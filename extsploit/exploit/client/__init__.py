import copy
import os
import threading
import time
from functools import wraps
from queue import Queue

from routersploit.core.exploit import Exploit, print_error, print_success
from routersploit.core.exploit import (
    OptInteger,
)
from routersploit.core.exploit import (
    print_table,
    print_status,
    print_info
)
from routersploit.core.exploit.exceptions import RoutersploitException
from routersploit.core.exploit.utils import is_ipv4, is_ipv6
from routersploit.extsploit.exploit.option import OptEngine, Option, OptSave
from routersploit.extsploit.exploit.utils import ReadableDict, get_targets_from_engine, get_save_protocal_info, save_to
from routersploit.extsploit.exploit.utils import get_engines_protocal_info
from routersploit.extsploit.settings import EXPLOIT_COMMAND, OUTPUT_DIR


class BaseClient(Exploit):
    """ Base class that can be adapted to multithreading for exploit """

    _targets_queue = Queue()  # Store multiple exploit targets
    _result_status_queue = Queue()  # Store exploit result status
    _result_queue = Queue()  # Store exploit result
    _is_lock = False  # For multi method, only allow decorating one function to avoid loop call
    threads = OptInteger(1, "Thread num for multi targets")  # If subclass not define threads, default 1

    def __init__(self):
        # Restore cls some attr from last use
        self.__class__._restore_cls_attr()

        # Copy cls Option attr as instance attr for reduce the priority of the descriptor
        for option, value in self.__class__._cls_options():
            self.__dict__[option] = copy.deepcopy(value)

        # Set save default dir
        file_name = self.__module__.split('.')[-1] + '_' + str(time.time()).replace('.', '') + '.json'
        file_path = os.path.join(OUTPUT_DIR, file_name)
        value = 'file://{}'.format(file_path)
        description = "Save module protocal, {}".format(' or '.join(get_save_protocal_info()))
        self.save = OptSave(value, description)
        self.exploit_attributes.update({'save': [value, description]})

    def __getattribute__(self, name):
        """
        (1) Reduce the priority of the descriptor, first get the attribute from the instance,
        (2) Intercept the exploit command call method, use the multi-thread call method
        """

        try:
            attr = object.__getattribute__(self, '__dict__')[name]
            if isinstance(attr, Option):
                attr = attr.__get__(self, type(self))
        except RoutersploitException as err:
            raise err
        except KeyError:
            attr = object.__getattribute__(self, name)
            if name in EXPLOIT_COMMAND and hasattr(attr, '__call__'):
                attr = getattr(object.__getattribute__(self, '__class__'), '_multi')(self, attr)
        return attr

    def __setattr__(self, name, value):
        """
        (1) Reduce the priority of the descriptor, first set the attribute for the instance
        """
        try:
            attr = object.__getattribute__(self, '__dict__')[name]
            if isinstance(attr, Option):
                attr.__set__(self, value)
        except RoutersploitException as err:
            raise err
        except KeyError:
            object.__setattr__(self, name, value)

    @classmethod
    def _cls_options(cls):
        """ Get cls option object and exploit_attributes attr
        :return:
        """
        for base in cls.__bases__:
            for key, value in base.__dict__.items():
                if isinstance(value, Option):
                    yield key, value
        for key, value in cls.__dict__.items():
            if isinstance(value, Option):
                yield key, value
        yield 'exploit_attributes', cls.exploit_attributes

    @classmethod
    def _restore_cls_attr(cls):
        """ Restore cls attr
        :return:
        """

        cls._targets_queue.queue.clear()
        cls._result_status_queue.queue.clear()
        cls._result_queue.queue.clear()
        cls._is_lock = False

    @classmethod
    def _multi(cls, exploit, func):
        """
        :param func: exploit method
        :return:
        """
        if cls._is_lock:
            return func

        @wraps(func)
        def _wrapper(*args, **kwargs):
            cls._is_lock = True

            # Check if exploit is a single ip set
            target = exploit.target
            port = exploit.port
            if (is_ipv4(target) or is_ipv6(target)) and port:
                cls._targets_queue.put((exploit, target, port))

            # Check if loading from search engine
            if exploit.engine:
                for target, port in get_targets_from_engine(exploit.engine):
                    if port:
                        port = port
                    elif exploit.port:
                        port = exploit.port
                    else:
                        port = 80
                    cls._targets_queue.put((exploit, target, port))

            print_info("Fetch {} target.".format(cls._targets_queue.qsize()))

            # Start multithreading handle
            cls._run_multi_threads(exploit.threads, cls._loop_thread, func, *args, **kwargs)

            # Save exploit result
            cls._save(exploit)

            cls._is_lock = False

        return _wrapper

    @classmethod
    def _run_multi_threads(cls, threads_number: int, target_function: any, *args, **kwargs):
        """ run multiple threads
        :param int threads_number: thread number
        :param target_function: target function
        :param args:
        :param kwargs:
        :return:
        """

        threads = []
        threads_running = threading.Event()
        threads_running.set()

        for thread_id in range(int(threads_number)):
            thread = threading.Thread(
                target=target_function,
                args=(threads_running,) + args,
                kwargs=kwargs,
            )
            threads.append(thread)

            thread.start()

        start = time.time()
        try:
            while thread.isAlive():
                thread.join(1)

        except KeyboardInterrupt:
            cls._restore_cls_attr()
            threads_running.clear()

        for thread in threads:
            thread.join()

        print_status("Elapsed time: {} seconds".format(time.time() - start))

    @classmethod
    def _loop_thread(cls, running: threading.Event, target_function, *args, **kwargs):
        """ Loop processing target
        :param threading.Event running: Thread communication object
        :param target_function: exploit target function
        :param args:
        :param kwargs:
        :return:
        """
        while running.is_set() and not cls._targets_queue.empty():
            exploit, target, port = cls._targets_queue.get()
            exploit = copy.deepcopy(
                exploit)  # Copy objects so that each object does not affect each other in multiple threads
            exploit.target, exploit.port = target, port
            exploit_name = str(exploit)
            print_status("Start exploit {} ,target:{} port:{}".format(exploit_name, exploit.target, exploit.port))
            try:
                result = getattr(exploit, target_function.__name__)(*args, **kwargs)
            except Exception as err:
                result = {}
                print_error(str(err))

            if result:
                if isinstance(result, dict):
                    result['Status'] = 'Success'
                print_success(
                    "Exploit {} target:{} port:{} success!!!\nresult:{}".format(exploit_name, target, port, result))
                cls._result_queue.put(result)
                cls._result_status_queue.put(
                    (exploit_name, exploit.target, exploit.port, exploit.target_protocol, "success"))

            else:
                cls._result_queue.put(
                    {'ExploitInfo': {'URL': "{}:{}".format(exploit.target, exploit.port)}, "Status": "fail"})
                cls._result_status_queue.put(
                    (exploit_name, exploit.target, exploit.port, exploit.target_protocol, "fail"))
                print_status(
                    "Exploit {} target:{} port:{} failed!!!".format(exploit_name, target, port))
            # Delete exploit duplicate
            del exploit

    @classmethod
    def _save(cls, exploit):
        """ Output to console and call all methods at the beginning of save_to_ in the subclass will be called
        :return:
        """

        # Output to console
        cls._output_console(exploit)

        # Call all save_to_ method
        results = {}
        num = 0
        while not cls._result_queue.empty():
            data = cls._result_queue.get()
            if isinstance(data, dict) and data:
                results.update({str(num): data})
                num += 1
        results = ReadableDict(results)
        if exploit.save and results:
            save_to(exploit.save, results)

    @classmethod
    def _output_console(cls, exploit):
        """ Output exploit result to the console
        :return:
        """
        output = []
        success = 0
        total = 0
        while not cls._result_status_queue.empty():
            result = cls._result_status_queue.get()
            if result[4] == 'success':
                success += 1
            output.append(result)
            total += 1
        print_table(('Exploit', 'Target', 'Port', 'Service', 'Status'), *output)
        print_info("   success: {}/{}".format(success, total))


class SearchClient(BaseClient):
    """ Search engine client
    """

    engine = OptEngine(None, "Save engine protocal, {}".format(' or '.join(get_engines_protocal_info())))
